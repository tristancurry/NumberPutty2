<html>
<!-- NumberPutty 2 2017 -->
<head>
<style>
.noselect {
  -webkit-touch-callout: none; /* iOS Safari */
    -webkit-user-select: none; /* Safari*/
     -khtml-user-select: none; /* Konqueror */
       -moz-user-select: none; /* Firefox */
        -ms-user-select: none; /* Internet Explorer/Edge */
            user-select: none; /* Non-prefixed version, currently
                                  supported by Chrome and Opera */
}

</style>
</head>


<body>

<div class="noselect" id="mainDiv">
<canvas id="viewport" width="600" height="600" style="position:absolute; top:0px; left:0px; z-index:1; border-style:inset; border-color:#FF0000; border-width:5px;"></canvas>
<canvas id="viewport2" width="600" height="600" style="position:absolute; top:0px; left:0px; z-index:0; border-style:inset; border-color:#FF0000; border-width:5px;"></canvas>
<div id="buttons" style="z-index:2; position:absolute; top:5px; left:5px; width:590px; height:50px; clear:both">
<button type="button" id="oneMore"  style="float:left; margin-left:20px;" onclick="help(1)">One more</button>
<button type="button" id="oneLess" style="float:right; margin-right:20px;" onclick="help(-1)">One less</button>
</div>
<div id="add1" style="position:absolute; z-index:3; width: 100px; height: 50px;">
<button type="button" >ADD</button>
</div>
</div>
<script src="physicsjs/physicsjs-full.min.js"></script>

<script>
   var requestAnimationFrame = window.requestAnimationFrame || 
                            window.mozRequestAnimationFrame || 
                            window.webkitRequestAnimationFrame || 
                            window.msRequestAnimationFrame;
							
   

var mainDiv = document.querySelector("#mainDiv");
var mainCanvas = document.querySelector("#viewport");
var mainContext = mainCanvas.getContext("2d");

var width = mainCanvas.width;
var height = mainCanvas.height;

var add1 = document.querySelector("#add1");

// left: 37, up: 38, right: 39, down: 40,
// spacebar: 32, pageup: 33, pagedown: 34, end: 35, home: 36
var keys = {37: 1, 38: 1, 39: 1, 40: 1};

function preventDefault(e) {
  e = e || window.event;
  if (e.preventDefault)
      e.preventDefault();
  e.returnValue = false;  
}

function preventDefaultForScrollKeys(e) {
    if (keys[e.keyCode]) {
        preventDefault(e);
        return false;
    }
}

function disableScroll() {
  if (window.addEventListener) // older FF
      window.addEventListener('DOMMouseScroll', preventDefault, false);
  window.onwheel = preventDefault; // modern standard
  window.onmousewheel = document.onmousewheel = preventDefault; // older browsers, IE
  window.ontouchmove  = preventDefault; // mobile
  document.onkeydown  = preventDefaultForScrollKeys;
}

function enableScroll() {
    if (window.removeEventListener)
        window.removeEventListener('DOMMouseScroll', preventDefault, false);
    window.onmousewheel = document.onmousewheel = null; 
    window.onwheel = null; 
    window.ontouchmove = null;  
    document.onkeydown = null;  
}


Physics.behavior('interactive-custom', function( parent ){

    if ( !document ){
        // must be in node environment
        return {};
    }

    var defaults = {
            // the element to monitor
            el: null,
            // time between move events
            moveThrottle: 1000 / 100 | 0,
            // minimum velocity clamp
            minVel: { x: -5, y: -5 },
            // maximum velocity clamp
            maxVel: { x: 5, y: 5 }
        }
        ,getElementOffset = function( el ){
            var curleft = 0
                ,curtop = 0
                ;

            if (el.offsetParent) {
                do {
                    curleft += el.offsetLeft;
                    curtop += el.offsetTop;
                } while (el = el.offsetParent);
            }

            return { left: curleft, top: curtop };
        }
        ,getCoords = function( e ){
            var offset = getElementOffset( e.target )
                ,obj = ( e.changedTouches && e.changedTouches[0] ) || e
                ,x = obj.pageX - offset.left
                ,y = obj.pageY - offset.top
                ;

            return {
                x: x
                ,y: y
            };
        }
        ;

    return {
        // extended
        init: function( options ){

            var self = this
                ,prevTreatment
                ,time
                ;

            // call parent init method
            parent.init.call( this );
            this.options.defaults( defaults );
            this.options( options );

            // vars
            this.mousePos = new Physics.vector();
            this.mousePosOld = new Physics.vector();
            this.offset = new Physics.vector();

            this.el = typeof this.options.el === 'string' ? document.getElementById(this.options.el) : this.options.el;

            if ( !this.el ){
                throw "No DOM element specified";
            }

            // init events
            var grab = function grab( e ){
                var pos = getCoords( e )
                    ,body
                    ;

                time = Physics.util.ticker.now();

                if ( self._world ){
                    body = self._world.findOne({ $at: new Physics.vector( pos.x, pos.y ), $in: self.getTargets() });
                    
                    

                    if ( body ){
                        // we're trying to grab a body

                        // fix the body in place
                        prevTreatment = body.treatment;
                        body.treatment = 'kinematic';
                        body.state.vel.zero();
                        body.state.angular.vel = 0;
                        // remember the currently grabbed body
                        self.body = body;
                        // remember the mouse offset
                        self.mousePos.clone( pos );
                        self.mousePosOld.clone( pos );
                        self.offset.clone( pos ).vsub( body.state.pos );

                        pos.body = body;
                        self._world.emit('interact:grab', pos);

                    } else {

                        self._world.emit('interact:poke', pos);
                    }
                }
            };

            var move = Physics.util.throttle(function move( e ){
                var pos = getCoords( e )
                    ,state
                    ;

                if ( self.body ){
                    time = Physics.util.ticker.now();

                    self.mousePosOld.clone( self.mousePos );
                    // get new mouse position
                    self.mousePos.set(pos.x, pos.y);

                    pos.body = self.body;
                }

                self._world.emit('interact:move', pos);

            }, self.options.moveThrottle);

            var release = function release( e ){
                var pos = getCoords( e )
                    ,body
                    ,dt = Math.max(Physics.util.ticker.now() - time, self.options.moveThrottle)
                    ;

                // get new mouse position
                self.mousePos.set(pos.x, pos.y);

                // release the body
                if (self.body){
                    self.body.treatment = prevTreatment;
                    // calculate the release velocity
                    self.body.state.vel.clone( self.mousePos ).vsub( self.mousePosOld ).mult( 1 / dt );
                    // make sure it's not too big
                    self.body.state.vel.clamp( self.options.minVel, self.options.maxVel );
                    self.body = false;
                }

                if ( self._world ){

                    self._world.emit('interact:release', pos);
                }
            };

            this.el.addEventListener('mousedown', grab);
            this.el.addEventListener('touchstart', grab);

            this.el.addEventListener('mousemove', move);
            this.el.addEventListener('touchmove', move);

            this.el.addEventListener('mouseup', release);
            this.el.addEventListener('touchend', release);
        },

        // extended
        connect: function( world ){

            // subscribe the .behave() method to the position integration step
            world.on('integrate:positions', this.behave, this);
        },

        // extended
        disconnect: function( world ){

            // unsubscribe when disconnected
            world.off('integrate:positions', this.behave);
        },

        // extended
        behave: function( data ){

            var self = this
                ,state
                ,dt = Math.max(data.dt, self.options.moveThrottle)
                ;

            if ( self.body ){

                // if we have a body, we need to move it the the new mouse position.
                // we'll do this by adjusting the velocity so it gets there at the next step
                state = self.body.state;
                state.vel.clone( self.mousePos ).vsub( self.offset ).vsub( state.pos ).mult( 1 / dt );
            }
        }
    };
});


Physics(function( world ){

	mainDiv.addEventListener('mousemove', function(event){
		mouseX = event.pageX - mainDiv.offsetLeft;
		mouseY = event.pageY - mainDiv.offsetTop;
	});
	
	
	doubleClick = function(){ 
	//do magical things involving breaking into two parts (eventually). Right now it just increments the value of the appropriate blob.
		for(n in world._bodies){
			var nB = world._bodies[n];
			var distSq = Math.pow(mouseX - nB.state.pos.x,2) + Math.pow(mouseY - nB.state.pos.y,2);
			if(distSq < Math.pow(nB.radius,2)){
				if(nB.value != 0 && nB.value != 1 && nB.value !=-1){
					smashBlob(nB);
					world.removeBody(nB);
					break;
				}
			}
		}
	}
	
	
	smashBlob = function(nB){
	var val = nB.value;
	var frags = [null, null];
	//if value is not zero, smash into (nearly) equal portions

		frags[0] = Math.floor(0.5*val);
		frags[1] = val - frags[0];

	
	for(f in frags){
		createBlob(frags[f],nB.state.pos.x, nB.state.pos.y, 0.2 - 0.4*Math.random(), 0.2 - 0.4*Math.random());
	}
	
	}
	
	
	
	
	mainCanvas.addEventListener('dblclick', doubleClick);
	
	

	
	//double-tap-zoom prevention (thanks Evrim Persembe at http://stackoverflow.com/questions/10614481/disable-double-tap-zoom-option-in-browser-on-touch-devices
	
	mainDiv.addEventListener('touchstart', preventZoom);
	
	
	var clickTimer = null;

	function touchStart(e) {
    if (clickTimer == null) {
        clickTimer = setTimeout(function () {
         clickTimer = null; 

        }, 500)
    } else {
        clearTimeout(clickTimer);
        clickTimer = null;
		e.preventDefault();
        doubleClick();

    }
}
	
	function preventZoom(e) {
		var t2 = e.timeStamp;
		var t1 = e.currentTarget.dataset.lastTouch || t2;
		var dt = t2 - t1;
		var fingers = e.touches.length;
		e.currentTarget.dataset.lastTouch = t2;

		if (!dt || dt > 500 || fingers > 1) {return;} // not double-tap
		else{
			e.preventDefault();
			doubleClick();
		}
	}



	//this might end up belonging to the 'blob' object itself
	function drawBlob(nB, ctx){
		ctx.save();
		ctx.strokeStyle = "rgba(255,255,255,1)";
		ctx.fillStyle = "rgba(30,30,90,0.7)";
		ctx.translate(nB.state.pos.x,nB.state.pos.y);
		ctx.rotate(nB.state.angular.pos);
		ctx.beginPath();
		ctx.arc(0,0,nB.radius,0,2*Math.PI);
		ctx.fill();
		ctx.stroke();
		ctx.fillStyle = "rgba(255,255,255,1)";
		ctx.font = "30px Helvetica";
		ctx.textAlign = "center";
		ctx.textBaseline = "middle";
		ctx.fillText(nB.value, 0,0);
		ctx.restore();
	}

   
	var bounds = Physics.aabb(0, 0, 600, 600);
	var clicks = 0;
	
	
	Physics.body('numberBlob', 'circle', function( parent ){
		return {

		
		
		};

	});

   help = function(val){
		clicks++;
		createBlob(val,mouseX,mouseY+30,0.4 - 0.8*Math.random(), 1);
		console.log("pressed " + clicks + " times");
   }
	
	
	createBlob = function(val, _x, _y, _vx, _vy){
		var rad = Math.ceil(30*Math.pow(Math.abs(val),0.25));
		world.add( Physics.body('numberBlob', {
		blob:true,
		name: 'blob',
			x: _x,
			y: _y,
			vx: _vx,
			vy: _vy,
			value: val,
			radius: rad,
			restitution: 0.2,
			cof: 0.8,
			mass: 0.001*Math.abs(val)
		
		}))
	}
        var bucket = Physics.body('compound', {
        x: 3*width/4
        ,y: height - 130
        ,treatment: 'static'
        ,styles: {
            fillStyle: "rgba(255,0,0,0.8)"
            ,lineWidth: 1
            ,strokeStyle: "rgba(100,0,0,0.8)"
            ,alpha: 0.0001 //pixi bug
        }
        ,children: [
        Physics.body('rectangle', {
            x: width/2 + 10
            ,y: height - 60 -150
            ,width: 20
            ,height: 300
            ,mass: 40
        })
		,Physics.body('rectangle', {
            x: width - 10
            ,y: height - 60 - 150
            ,width: 20
            ,height: 300
            ,mass: 40
        })
        ,Physics.body('rectangle', {
            x: 3*width/4
            ,y: height - 30
            ,width: width/2
            ,height: 60
            ,mass: 40
        })
        ]
    });
	
	world.add(bucket);
   
	var renderer = Physics.renderer('canvas', {
		autoResize: false,
		el: 'viewport', // id of the canvas element
		width: 600,
		height: 600,
	});
	
	//default renderer is just being used to handle the dragging at this stage
	world.add( renderer ); 
   
	

	(function(){
	var budget = 50;
	do {
		var thisVal = Math.ceil(budget*Math.random());
		createBlob(thisVal,250,250, 0,0);
		budget = budget - thisVal
		} while (budget > 0);
	})();
	
	
	
	//adding behaviours to world
	world.add( Physics.behavior('edge-collision-detection', {
		aabb: bounds,
		restitution: 0.3  //default is 1.0 for perfectly elastic collision 
	}) );
	// ensure objects bounce when edge collision is detected
	world.add( Physics.behavior('body-impulse-response') );
	world.add( Physics.behavior('constant-acceleration', {  acc: { x : 0, y: 0.00040 }}) );
	world.add( Physics.behavior('body-collision-detection') );
	world.add( Physics.behavior('sweep-prune') );
	world.add( Physics.behavior('interactive-custom', { el: renderer.el }).applyTo(world.find({ name: 'blob' })));

	//this is the main rendering/updating/interface loop
	
	drawWorld = function(){
		mainContext.fillStyle = "rgba(20,0,20,1)";
		mainContext.fillRect(0,0, width, height);
		for(n in world._bodies){
		if(world._bodies[n].blob){
			drawBlob(world._bodies[n], mainContext);
		}
		}
		world.step();
		world.render();
		var deg = 360*bucket.state.angular.pos/(2*Math.PI);
		var pos = [bucket.state.pos.x + 50,bucket.state.pos.y];
		add1.style.transform = 'translate('+pos[0]+'px, '+pos[1]+'px) rotate('+deg+'deg) ';
		//add1.style.webkitTransform = 'rotate('+deg+'deg)';
		//add1.style.mozTransform    = 'rotate('+deg+'deg)'; 
		//add1.style.msTransform     = 'rotate('+deg+'deg)';
		//add1.style.oTransform      = 'rotate('+deg+'deg)';
		requestAnimationFrame(drawWorld);
	}
	disableScroll();
		mainContext.fillStyle = "rgba(20,0,20,1)";
		mainContext.fillRect(0,0, width, height);
	drawWorld();
});


</script>
</body>
</html>